{"config":{"lang":["en"],"separator":"[\\s\\-\\.\\_]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Home","text":""},{"location":"#ckanext-tables","title":"ckanext-tables","text":"<p>A CKAN extension to display tabular data in a nice way using Tabulator.</p> <p>See the documentation for more information.</p>"},{"location":"#tests","title":"Tests","text":"<p>To run the tests, do: <pre><code>pytest --ckan-ini=test.ini\n</code></pre></p>"},{"location":"#license","title":"License","text":"<p>AGPL</p>"},{"location":"generics/","title":"Generic Views","text":"<p>The <code>ckanext.tables.generics</code> module provides a ready-to-use view class that can render tables without writing custom view code.</p>"},{"location":"generics/#generictableview","title":"GenericTableView","text":"<p>The <code>GenericTableView</code> is a Flask <code>MethodView</code> that automatically renders any registered table definition.</p>"},{"location":"generics/#basic-usage","title":"Basic Usage","text":"<pre><code>from flask import Blueprint\n\nfrom ckanext.tables.shared import GenericTableView\nfrom ckanext.tables_demo.table import PeopleTable\n\nbp = Blueprint(\"tables_demo\", __name__, url_prefix=\"/tables-demo\")\n\nbp.add_url_rule(\"/people\", view_func=GenericTableView.as_view(\"people\", table=PeopleTable))\n</code></pre>"},{"location":"generics/#constructor-parameters","title":"Constructor Parameters","text":"<ul> <li><code>table</code> (<code>type[TableDefinition]</code>, required): The table definition class to be rendered.</li> <li><code>breadcrumb_label</code> (<code>str</code>, optional): Label shown in breadcrumbs. Defaults to \"Table\"</li> <li><code>page_title</code> (<code>str</code>, optional): Page title shown in the browser/header. Defaults to empty string</li> </ul>"},{"location":"generics/#access-control","title":"Access Control","text":"<p>The <code>GenericTableView</code> delegates access control to the table definition's <code>check_access()</code> method. Make sure your table definitions implement proper authorization:</p> <pre><code>class PeopleTable(TableDefinition):\n    ...\n\n    @classmethod\n    def check_access(cls, context: Context) -&gt; None:\n        \"\"\"Only allow sysadmins to view this table.\"\"\"\n        tk.check_access(\"sysadmin\", context)\n</code></pre>"},{"location":"helpers/","title":"Helper Functions","text":"<p>CKAN helper functions are typically used in templates, but also available everywhere with <code>toolkit.h.helper_name()</code>.</p>"},{"location":"helpers/#tables.helpers.tables_get_filters_from_request","title":"<code>tables_get_filters_from_request()</code>","text":"<p>Get the filters from the request arguments.</p> RETURNS DESCRIPTION <code>list[FilterItem]</code> <p>A dictionary of filters</p> Source code in <code>ckanext/tables/helpers.py</code> <pre><code>def tables_get_filters_from_request() -&gt; list[table.FilterItem]:\n    \"\"\"Get the filters from the request arguments.\n\n    Returns:\n        A dictionary of filters\n    \"\"\"\n    fields = tk.request.args.getlist(\"field\")\n    operators = tk.request.args.getlist(\"operator\")\n    values = tk.request.args.getlist(\"value\")\n\n    return [\n        table.FilterItem(field=field, operator=op, value=value)\n        for field, op, value in zip(fields, operators, values, strict=True)\n    ]\n</code></pre>"},{"location":"helpers/#tables.helpers.tables_json_dumps","title":"<code>tables_json_dumps(value)</code>","text":"<p>Convert a value to a JSON string.</p> PARAMETER DESCRIPTION <code>value</code> <p>The value to convert to a JSON string</p> <p> TYPE: <code>Any</code> </p> RETURNS DESCRIPTION <code>str</code> <p>The JSON string</p> Source code in <code>ckanext/tables/helpers.py</code> <pre><code>def tables_json_dumps(value: Any) -&gt; str:\n    \"\"\"Convert a value to a JSON string.\n\n    Args:\n        value: The value to convert to a JSON string\n\n    Returns:\n        The JSON string\n    \"\"\"\n    return json.dumps(value)\n</code></pre>"},{"location":"install/","title":"Installation","text":""},{"location":"install/#requirements","title":"Requirements","text":"<p>Python 3.10+</p> <p>Compatibility with core CKAN versions:</p> CKAN version Compatible? 2.9 and earlier no 2.10 yes 2.11 yes master not tested"},{"location":"install/#installation_1","title":"Installation","text":"<p>To install <code>ckanext-tables</code>, do the following:</p> <ul> <li> <p>Activate your CKAN virtualenv and install the extension with <code>pip</code>:</p> <pre><code>pip install ckanext-tables\n</code></pre> </li> <li> <p>Add <code>tables</code> to the <code>ckan.plugins</code> setting in your CKAN    config file (by default the config file is located at    <code>/etc/ckan/default/ckan.ini</code>).</p> <pre><code>ckan.plugins = ... tables ...\n</code></pre> </li> </ul>"},{"location":"install/#developer-installation","title":"Developer installation","text":"<p>To install <code>ckanext-tables</code> for development, activate your CKAN virtualenv and do:</p> <pre><code>git clone https://github.com/DataShades/ckanext-tables.git\ncd ckanext-tables\npip install -e '.[docs,test]'\n</code></pre>"},{"location":"usage/","title":"Basic usage","text":"<p>Here you can find complete usage instructions for the Tables extension. The process is fairly simple and involves only several steps:</p> <ol> <li>Defining a table</li> <li>Creating a view to display the table</li> </ol> <p>We're going to use a demo table definition called <code>PeopleTable</code> for demonstration purposes.</p> <p>It's a working example located in a separate extension and can be enabled alongside the tables extension. Just add <code>tables_demo</code> to your <code>ckan.plugins</code> configuration.</p> <p>The demo table uses all the features of the tables extension, including data sources, formatters, all action types, and exporters. A minimal example could be much simpler, but this one demonstrates the full power of the extension.</p>"},{"location":"usage/#defining-a-table","title":"Defining a Table","text":"<p>First, create a table definition by inheriting from <code>TableDefinition</code>.</p> <p>We will use the <code>ListDataSource</code> with a mock data for demonstration purposes, but in a real-world scenario, you might want to use <code>DatabaseDataSource</code> or create a custom data source. Read more about data sources here.</p> <p>In general, <code>ListDataSource</code> is suitable for small datasets or testing, while <code>DatabaseDataSource</code> is recommended for production use with larger datasets.</p> <p>If you're interested in how we're generating the mock data, check out the <code>generate_mock_data</code> function below:</p> Source code in <code>ckanext/tables_demo/utils.py</code> <pre><code>def generate_mock_data(num_records: int) -&gt; list[dict[str, str]]:\n    fake = Faker()\n\n    return [\n        {\n            \"id\": str(i),\n            \"name\": fake.first_name(),\n            \"surname\": fake.last_name(),\n            \"email\": fake.email(),\n            \"created\": fake.date_time_this_decade().isoformat(),\n        }\n        for i in range(1, num_records + 1)\n    ]\n</code></pre> <p>Below is the full code of the <code>PeopleTable</code> definition:</p> <pre><code>import ckanext.tables.shared as t\nfrom ckanext.tables_demo.utils import generate_mock_data\n\nDATA = generate_mock_data(1000)\n\n\nclass PeopleTable(t.TableDefinition):\n    \"\"\"Demo table definition for the people table.\"\"\"\n\n    def __init__(self):\n        super().__init__(\n            name=\"people\",\n            data_source=t.ListDataSource(data=DATA),\n            columns=[\n                t.ColumnDefinition(field=\"id\", width=70),\n                t.ColumnDefinition(field=\"name\"),\n                t.ColumnDefinition(field=\"surname\", title=\"Last Name\"),\n                t.ColumnDefinition(field=\"email\"),\n                t.ColumnDefinition(\n                    field=\"created\",\n                    formatters=[\n                        (t.formatters.DateFormatter, {\"date_format\": \"%d %B %Y\"})\n                    ],\n                ),\n            ],\n            row_actions=[\n                t.RowActionDefinition(\n                    action=\"remove_user\",\n                    label=\"Remove User\",\n                    icon=\"fa fa-trash\",\n                    callback=self.remove_user,\n                    with_confirmation=True,\n                ),\n            ],\n            bulk_actions=[\n                t.BulkActionDefinition(\n                    action=\"remove_user\",\n                    label=\"Remove Selected Users\",\n                    icon=\"fa fa-trash\",\n                    callback=self.remove_users,\n                ),\n            ],\n            table_actions=[\n                t.TableActionDefinition(\n                    action=\"remove_all_users\",\n                    label=\"Remove All Users\",\n                    icon=\"fa fa-trash\",\n                    callback=self.remove_all_users,\n                ),\n                t.TableActionDefinition(\n                    action=\"recreate_users\",\n                    label=\"Recreate Users\",\n                    icon=\"fa fa-refresh\",\n                    callback=self.recreate_users,\n                ),\n            ],\n            exporters=t.ALL_EXPORTERS,\n        )\n\n    def remove_user(self, row: t.Row) -&gt; t.ActionHandlerResult:\n        \"\"\"Callback to remove a user from the data source.\"\"\"\n        DATA[:] = [r for r in DATA if r[\"id\"] != row[\"id\"]]\n        return t.ActionHandlerResult(success=True, message=\"User removed.\")\n\n    def remove_users(self, rows: list[t.Row]) -&gt; t.ActionHandlerResult:\n        \"\"\"Callback to remove a user from the data source.\"\"\"\n        ids_to_remove = {row[\"id\"] for row in rows}\n        DATA[:] = [r for r in DATA if r[\"id\"] not in ids_to_remove]\n        return t.ActionHandlerResult(success=True, message=\"Users removed.\")\n\n    def remove_all_users(self) -&gt; t.ActionHandlerResult:\n        \"\"\"Callback to remove all users from the data source.\"\"\"\n        DATA.clear()\n        return t.ActionHandlerResult(success=True, message=\"All users removed.\")\n\n    def recreate_users(self) -&gt; t.ActionHandlerResult:\n        \"\"\"Callback to recreate the mock users.\"\"\"\n        DATA[:] = generate_mock_data(1000)\n        return t.ActionHandlerResult(success=True, message=\"Users recreated.\")\n</code></pre>"},{"location":"usage/#using-formatters","title":"Using Formatters","text":"<p>The tables extension provides several built-in formatters to change the way data is rendered in the table cells. You can apply one or more formatters to a column by specifying them in the <code>formatters</code> attribute of <code>ColumnDefinition</code>.</p> <p>For example, from the above <code>PeopleTable</code>, we are using the <code>datetime</code> formatter to format the <code>created</code> field. So this <code>2024-02-25T11:10:00Z</code> value will be displayed as <code>2024-02-25</code>.</p> <pre><code>ColumnDefinition(\n    field=\"created\",\n    formatters=[(formatters.DateFormatter, {\"date_format\": \"%Y-%m-%d\"})],\n    sortable=True\n),\n</code></pre>"},{"location":"usage/#using-exporters","title":"Using Exporters","text":"<p>The tables extension also provides several built-in exporters to export the table data in different formats. You can specify the exporters to be used in the <code>exporters</code> attribute of the <code>TableDefinition</code>.</p> <p>In the above <code>PeopleTable</code>, we are using all the available exporters by specifying <code>t.ALL_EXPORTERS</code>. You can also specify individual exporters if you want to limit the available export options.</p> <pre><code>exporters=[\n    t.exporters.CSVExporter,\n    t.exporters.TSVExporter,\n],\n</code></pre> <p>Obviously, you can write your own custom exporters as well. See the exporters documentation for more information.</p>"},{"location":"usage/#using-actions","title":"Using Actions","text":"<p>The tables extension allows you to define actions that can be performed on individual rows or on multiple selected rows. You can define these actions in the <code>row_actions</code>, <code>table_actions</code> and <code>bulk_actions</code> attributes of the <code>TableDefinition</code>.</p> <p>Basically, it's just a matter of defining the action and providing a callback function that will be called when the action is triggered.</p> <p>Read more about actions in the actions documentation.</p>"},{"location":"usage/#creating-a-view","title":"Creating a View","text":"<p>Once your table is defined, you can create a view to display it using the <code>GenericTableView</code>:</p> <pre><code>from flask import Blueprint\n\nfrom ckanext.tables.shared import GenericTableView\nfrom ckanext.tables_demo.table import PeopleTable\n\nbp = Blueprint(\"tables_demo\", __name__, url_prefix=\"/tables-demo\")\n\nbp.add_url_rule(\"/people\", view_func=GenericTableView.as_view(\"people\", table=PeopleTable))\n</code></pre> <p>As you can see, this view does not require any custom code to render the table. The <code>GenericTableView</code> takes care of everything.</p>"},{"location":"usage/#results","title":"Results","text":"<p>After completing the above steps, you can navigate to <code>/admin/people</code> in your CKAN instance to see the rendered table.</p> <p></p>"},{"location":"usage/#next-steps","title":"Next Steps","text":"<ul> <li>Learn about Data Sources for different data backends</li> <li>Explore Built-In and Custom Formatters to enhance table presentation.</li> <li>Explore Actions to add interactivity to your tables.</li> <li>Explore Exporters to provide data export functionality.</li> </ul>"},{"location":"data_sources/","title":"Data Sources","text":"<p>Data sources provide the underlying data for table definitions. They handle filtering, sorting, and pagination operations while abstracting away the specific data storage mechanism.</p> <p>Each table definition must specify a data source to fetch its data from.</p> <p>The list of available data sources includes:</p> <ul> <li><code>DatabaseDataSource</code>: Uses SQLAlchemy statements to fetch data from the database. This is the most common data source for production use.</li> <li><code>ListDataSource</code>: Uses an in-memory list of dictionaries. This is useful for small datasets or testing.</li> </ul>"},{"location":"data_sources/database/","title":"DatabaseDataSource","text":"<p>The <code>DatabaseDataSource</code> uses SQLAlchemy statements to fetch data from the database. This is the most common data source for production use.</p>"},{"location":"data_sources/database/#basic-usage","title":"Basic Usage","text":"<pre><code>from sqlalchemy import select\n\nfrom ckan import model\n\nfrom ckanext.tables.shared import DatabaseDataSource\n\n\ndata_source = DatabaseDataSource(\n    stmt=select(\n        model.User.id,\n        model.User.email,\n        model.User.name,\n        model.User.state,\n    ).order_by(model.User.created.desc()),\n    model=model.User,\n)\n</code></pre>"},{"location":"data_sources/database/#definition","title":"Definition","text":"<p>A data source that uses a SQLAlchemy statement as the data source.</p> PARAMETER DESCRIPTION <code>stmt</code> <p>The SQLAlchemy statement to use as the data source</p> <p> TYPE: <code>Select</code> </p> <code>model</code> <p>The model class to use for filtering and sorting, e.g. <code>model.User</code></p> <p> TYPE: <code>type[Any]</code> </p> Source code in <code>ckanext/tables/data_sources.py</code> <pre><code>class DatabaseDataSource(BaseDataSource):\n    \"\"\"A data source that uses a SQLAlchemy statement as the data source.\n\n    Args:\n        stmt: The SQLAlchemy statement to use as the data source\n        model: The model class to use for filtering and sorting, e.g. `model.User`\n    \"\"\"\n\n    def __init__(self, stmt: Select, model: type[Any]):\n        self.base_stmt = stmt\n        self.stmt = stmt\n        self.model = model\n\n    def filter(self, filters: list[FilterItem]) -&gt; Self:\n        self.stmt = self.base_stmt\n\n        for filter_item in filters:\n            col = getattr(self.model, filter_item.field)\n            expr = self.build_filter(col, filter_item.operator, filter_item.value)\n\n            if expr is not None:\n                self.stmt = self.stmt.where(expr)\n\n        return self\n\n    def build_filter(self, column: ColumnElement, operator: str, value: str) -&gt; BinaryExpression | ClauseElement | None:\n        try:\n            if isinstance(column.type, Boolean):\n                casted_value = value.lower() in (\"true\", \"1\", \"yes\", \"y\")\n            elif isinstance(column.type, Integer):\n                casted_value = int(value)\n            elif isinstance(column.type, DateTime):\n                casted_value = datetime.fromisoformat(value)\n            else:\n                casted_value = str(value)\n        except ValueError:\n            return None\n\n        operators: dict[\n            str,\n            Callable[[ColumnElement, Any], BinaryExpression | ClauseElement | None],\n        ] = {\n            \"=\": lambda col, val: col == val,\n            \"&lt;\": lambda col, val: col &lt; val,\n            \"&lt;=\": lambda col, val: col &lt;= val,\n            \"&gt;\": lambda col, val: col &gt; val,\n            \"&gt;=\": lambda col, val: col &gt;= val,\n            \"!=\": lambda col, val: col != val,\n            \"like\": lambda col, val: (col.ilike(f\"%{val}%\") if isinstance(val, str) else None),\n        }\n\n        func = operators.get(operator)\n        return func(column, casted_value) if func else None\n\n    def sort(self, sort_by: str | None, sort_order: str | None) -&gt; Self:\n        if not sort_by or not hasattr(self.model, sort_by):\n            return self\n\n        col = getattr(self.model, sort_by)\n\n        # Clear existing order_by clauses\n        self.stmt = self.stmt.order_by(None)\n\n        if sort_order and sort_order.lower() == \"desc\":\n            self.stmt = self.stmt.order_by(col.desc())\n        else:\n            self.stmt = self.stmt.order_by(col.asc())\n\n        return self\n\n    def paginate(self, page: int, size: int) -&gt; Self:\n        if page and size:\n            self.stmt = self.stmt.limit(size).offset((page - 1) * size)\n\n        return self\n\n    def all(self) -&gt; list[dict[str, Any]]:\n        return [self.serialize_row(row) for row in model.Session.execute(self.stmt).mappings().all()]  # type: ignore\n\n    def serialize_row(self, row: RowMapping) -&gt; dict[str, Any]:\n        return dict(row)\n\n    def count(self) -&gt; int:\n        return model.Session.execute(select(func.count()).select_from(self.stmt.subquery())).scalar_one()\n</code></pre>"},{"location":"data_sources/database/#best-practices","title":"Best Practices","text":"<ul> <li>Use selective queries</li> <li>Add database indexes for commonly filtered/sorted columns</li> </ul> <pre><code># Good: Select only needed columns\nstmt = select(model.User.id, model.User.name, model.User.email)\n\n# Avoid: Selecting everything\nstmt = select(model.User)\n</code></pre>"},{"location":"data_sources/list/","title":"ListDataSource","text":"<p>The <code>ListDataSource</code> works with Python lists of dictionaries. It is useful for small datasets, testing, demos, or when working with preloaded data.</p>"},{"location":"data_sources/list/#basic-usage","title":"Basic Usage","text":"<pre><code>from ckanext.tables.shared import ListDataSource\n\n# Sample data\nusers_data = [\n    {\"id\": 1, \"name\": \"alice\", \"email\": \"alice@example.com\", \"age\": 30},\n    {\"id\": 2, \"name\": \"bob\", \"email\": \"bob@example.com\", \"age\": 25},\n    {\"id\": 3, \"name\": \"charlie\", \"email\": \"charlie@example.com\", \"age\": 35},\n]\n\ndata_source = ListDataSource(users_data)\n</code></pre>"},{"location":"data_sources/list/#definition","title":"Definition","text":"<p>A data source that uses a list of dictionaries as the data source.</p> <p>This is useful for testing and demo purposes, when you already have data on your hand.</p> PARAMETER DESCRIPTION <code>data</code> <p>The list of dictionaries to use as the data source</p> <p> TYPE: <code>list[dict[str, Any]]</code> </p> Source code in <code>ckanext/tables/data_sources.py</code> <pre><code>class ListDataSource(BaseDataSource):\n    \"\"\"A data source that uses a list of dictionaries as the data source.\n\n    This is useful for testing and demo purposes, when you already have data\n    on your hand.\n\n    Args:\n        data: The list of dictionaries to use as the data source\n\n    \"\"\"\n\n    def __init__(self, data: list[dict[str, Any]]):\n        self.data = data\n        self.filtered = data\n\n    def filter(self, filters: list[FilterItem]) -&gt; Self:\n        self.filtered = self.data\n\n        for filter_item in filters:\n            pred = self.build_filter(filter_item.field, filter_item.operator, filter_item.value)\n\n            if pred:\n                self.filtered = [row for row in self.filtered if pred(row)]\n\n        return self\n\n    def build_filter(self, field: str, operator: str, value: str) -&gt; Callable[[dict[str, Any]], bool] | None:\n        operators: dict[str, Callable[[str, str], bool]] = {\n            \"=\": lambda a, b: a == b,\n            \"!=\": lambda a, b: a != b,\n            \"&lt;\": lambda a, b: a &lt; b,\n            \"&lt;=\": lambda a, b: a &lt;= b,\n            \"&gt;\": lambda a, b: a &gt; b,\n            \"&gt;=\": lambda a, b: a &gt;= b,\n            \"like\": lambda a, b: b.lower() in a.lower(),\n        }\n\n        if op_func := operators.get(operator):\n            return lambda row: op_func(str(row.get(field, \"\")), str(value))\n\n        return None\n\n    def sort(self, sort_by: str | None, sort_order: str | None) -&gt; Self:\n        if not sort_by:\n            return self\n\n        self.filtered = sorted(\n            self.filtered,\n            key=lambda x: x.get(sort_by),\n            reverse=(sort_order or \"\").lower() == \"desc\",\n        )\n\n        return self\n\n    def paginate(self, page: int, size: int) -&gt; Self:\n        if page and size:\n            start = (page - 1) * size\n            end = start + size\n            self.filtered = self.filtered[start:end]\n        return self\n\n    def all(self):\n        return self.filtered\n\n    def count(self):\n        return len(self.filtered)\n</code></pre>"},{"location":"data_sources/list/#best-practices","title":"Best Practices","text":"<ul> <li>Suitable for small amout of data</li> <li>Consider caching expensive data preparation</li> </ul>"},{"location":"entities/","title":"Table Entity Definitions","text":"<p>The core concept of the tables extension is the Table Definition. A table definition describes the structure of a table, including its data source, columns, and formatting options.</p> <p>In the Usage section, we demonstrated how to create a simple table definition by subclassing <code>TableDefinition</code> and defining columns using <code>ColumnDefinition</code>.</p>"},{"location":"entities/actions/","title":"Action Definitions","text":"<p>Actions are operations that can be performed on table data There are 3 types of actions: bulk actions, table actions, and row actions.</p> <ol> <li>Bulk Actions: Actions that can be performed on multiple selected rows. Selected rows are passed to the action callback, allowing for operations on multiple items at once.</li> <li>Table Actions: Actions that can be performed on the table as a whole. It doesn't have an access to the row data, so it's typically used for operations that affect the entire table, e.g. cleaning the table data.</li> <li>Row Actions: Actions that can be performed on individual rows. These actions are acce</li> </ol> <p>Each action callback returns an <code>ActionHandlerResult</code> object, below you can see its definition:</p>"},{"location":"entities/actions/#tables.types.ActionHandlerResult","title":"<code>ActionHandlerResult</code>","text":"<p>               Bases: <code>TypedDict</code></p> <p>Represents the result of an action handler.</p> ATTRIBUTE DESCRIPTION <code>success</code> <p>Indicates whether the action was successful.</p> <p> TYPE: <code>bool</code> </p> <code>error</code> <p>(Optional) Error message if the action failed.</p> <p> TYPE: <code>NotRequired[str | None]</code> </p> <code>redirect</code> <p>(Optional) URL to redirect to after the action.</p> <p> TYPE: <code>NotRequired[str | None]</code> </p> <code>message</code> <p>(Optional) Informational message about the action result.</p> <p> TYPE: <code>NotRequired[str | None]</code> </p> Source code in <code>ckanext/tables/types.py</code> <pre><code>class ActionHandlerResult(TypedDict):\n    \"\"\"Represents the result of an action handler.\n\n    Attributes:\n        success: Indicates whether the action was successful.\n        error: (Optional) Error message if the action failed.\n        redirect: (Optional) URL to redirect to after the action.\n        message: (Optional) Informational message about the action result.\n    \"\"\"\n    success: bool\n    error: NotRequired[str | None]\n    redirect: NotRequired[str | None]\n    message: NotRequired[str | None]\n</code></pre>"},{"location":"entities/actions/#tables.table.BulkActionDefinition","title":"<code>BulkActionDefinition</code>  <code>dataclass</code>","text":"<p>Defines an action that can be performed on multiple rows.</p> ATTRIBUTE DESCRIPTION <code>action</code> <p>Unique identifier for the action.</p> <p> TYPE: <code>str</code> </p> <code>label</code> <p>Display label for the action.</p> <p> TYPE: <code>str</code> </p> <code>callback</code> <p>Function to be called when the action is triggered.</p> <p> TYPE: <code>Callable[[list[Row]], ActionHandlerResult]</code> </p> <code>icon</code> <p>(Optional) Icon class for the action.</p> <p> TYPE: <code>str | None</code> </p> Source code in <code>ckanext/tables/table.py</code> <pre><code>@dataclass(frozen=True)\nclass BulkActionDefinition:\n    \"\"\"Defines an action that can be performed on multiple rows.\n\n    Attributes:\n        action: Unique identifier for the action.\n        label: Display label for the action.\n        callback: Function to be called when the action is triggered.\n        icon: (Optional) Icon class for the action.\n    \"\"\"\n\n    action: str\n    label: str\n    callback: Callable[[list[types.Row]], types.ActionHandlerResult]\n    icon: str | None = None\n\n    def __call__(self, rows: list[types.Row]) -&gt; types.ActionHandlerResult:\n        return self.callback(rows)\n</code></pre>"},{"location":"entities/actions/#tables.table.TableActionDefinition","title":"<code>TableActionDefinition</code>  <code>dataclass</code>","text":"<p>Defines an action that can be performed on the table itself.</p> ATTRIBUTE DESCRIPTION <code>action</code> <p>Unique identifier for the action.</p> <p> TYPE: <code>str</code> </p> <code>label</code> <p>Display label for the action.</p> <p> TYPE: <code>str</code> </p> <code>callback</code> <p>Function to be called when the action is triggered.</p> <p> TYPE: <code>Callable[..., ActionHandlerResult]</code> </p> <code>icon</code> <p>(Optional) Icon class for the action.</p> <p> TYPE: <code>str | None</code> </p> Source code in <code>ckanext/tables/table.py</code> <pre><code>@dataclass(frozen=True)\nclass TableActionDefinition:\n    \"\"\"Defines an action that can be performed on the table itself.\n\n    Attributes:\n        action: Unique identifier for the action.\n        label: Display label for the action.\n        callback: Function to be called when the action is triggered.\n        icon: (Optional) Icon class for the action.\n    \"\"\"\n\n    action: str\n    label: str\n    callback: Callable[..., types.ActionHandlerResult]\n    icon: str | None = None\n\n    def __call__(self) -&gt; types.ActionHandlerResult:\n        return self.callback()\n</code></pre>"},{"location":"entities/actions/#tables.table.RowActionDefinition","title":"<code>RowActionDefinition</code>  <code>dataclass</code>","text":"<p>Defines an action that can be performed on a row.</p> ATTRIBUTE DESCRIPTION <code>action</code> <p>Unique identifier for the action.</p> <p> TYPE: <code>str</code> </p> <code>label</code> <p>Display label for the action.</p> <p> TYPE: <code>str</code> </p> <code>callback</code> <p>Function to be called when the action is triggered.</p> <p> TYPE: <code>Callable[[Row], ActionHandlerResult]</code> </p> <code>icon</code> <p>(Optional) Icon class for the action.</p> <p> TYPE: <code>str | None</code> </p> <code>with_confirmation</code> <p>(Optional) Whether to show a confirmation dialog before executing the action.</p> <p> TYPE: <code>bool</code> </p> Source code in <code>ckanext/tables/table.py</code> <pre><code>@dataclass(frozen=True)\nclass RowActionDefinition:\n    \"\"\"Defines an action that can be performed on a row.\n\n    Attributes:\n        action: Unique identifier for the action.\n        label: Display label for the action.\n        callback: Function to be called when the action is triggered.\n        icon: (Optional) Icon class for the action.\n        with_confirmation: (Optional) Whether to show a confirmation dialog before executing the action.\n    \"\"\"\n\n    action: str\n    label: str\n    callback: Callable[[types.Row], types.ActionHandlerResult]\n    icon: str | None = None\n    with_confirmation: bool = False\n\n    def __call__(self, row: types.Row) -&gt; types.ActionHandlerResult:\n        return self.callback(row)\n</code></pre>"},{"location":"entities/column/","title":"Column Definition","text":"<p>The column definition holds the configuration for a table column, including its field name, data type, formatters, and other options.</p> <p>Below you can check the available attributes of the <code>ColumnDefinition</code> class and their descriptions. Also, a full code is provided at the end of this document for reference.</p> <p>Column definition.</p> ATTRIBUTE DESCRIPTION <code>field</code> <p>The field name in the data dictionary.</p> <p> TYPE: <code>str</code> </p> <code>title</code> <p>The display title for the column. Defaults to a formatted version of <code>field</code>.</p> <p> TYPE: <code>str | None</code> </p> <code>formatters</code> <p>List of custom server-side formatters to apply to the column's value.</p> <p> TYPE: <code>list[tuple[type[BaseFormatter], dict[str, Any]]]</code> </p> <code>tabulator_formatter</code> <p>The name of a built-in Tabulator.js formatter (e.g., \"plaintext\").</p> <p> TYPE: <code>str | None</code> </p> <code>tabulator_formatter_params</code> <p>Parameters for the built-in tabulator formatter.</p> <p> TYPE: <code>dict[str, Any]</code> </p> <code>width</code> <p>The width of the column in pixels.</p> <p> TYPE: <code>int | None</code> </p> <code>min_width</code> <p>The minimum width of the column in pixels.</p> <p> TYPE: <code>int | None</code> </p> <code>visible</code> <p>Whether the column is visible.</p> <p> TYPE: <code>bool</code> </p> <code>sorter</code> <p>The default sorter for the column (e.g., \"string\", \"number\").</p> <p> TYPE: <code>bool</code> </p> <code>filterable</code> <p>Whether the column can be filtered by the user.</p> <p> TYPE: <code>bool</code> </p> <code>resizable</code> <p>Whether the column is resizable by the user.</p> <p> TYPE: <code>bool</code> </p> <code>tooltip</code> <p>Whether to show a tooltip with the full content on hover.</p> <p> TYPE: <code>bool</code> </p> <code>vertical_align</code> <p>Vertical alignment of the column content. Defaults to \"middle\".</p> <p> TYPE: <code>str</code> </p> <code>horizontal_align</code> <p>Horizontal alignment of the column content. Defaults to \"\".</p> <p> TYPE: <code>str</code> </p> Source code in <code>ckanext/tables/table.py</code> <pre><code>@dataclass(frozen=True)\nclass ColumnDefinition:\n    \"\"\"Column definition.\n\n    Attributes:\n        field: The field name in the data dictionary.\n        title: The display title for the column. Defaults to a formatted version of `field`.\n        formatters: List of custom server-side formatters to apply to the column's value.\n        tabulator_formatter: The name of a built-in Tabulator.js formatter (e.g., \"plaintext\").\n        tabulator_formatter_params: Parameters for the built-in tabulator formatter.\n        width: The width of the column in pixels.\n        min_width: The minimum width of the column in pixels.\n        visible: Whether the column is visible.\n        sorter: The default sorter for the column (e.g., \"string\", \"number\").\n        filterable: Whether the column can be filtered by the user.\n        resizable: Whether the column is resizable by the user.\n        tooltip: Whether to show a tooltip with the full content on hover.\n        vertical_align: Vertical alignment of the column content. Defaults to \"middle\".\n        horizontal_align: Horizontal alignment of the column content. Defaults to \"\".\n    \"\"\"\n\n    field: str\n    title: str | None = None\n    formatters: list[tuple[type[formatters.BaseFormatter], dict[str, Any]]] = dataclass_field(default_factory=list)\n    tabulator_formatter: str | None = None\n    tabulator_formatter_params: dict[str, Any] = dataclass_field(default_factory=dict)\n    width: int | None = None\n    min_width: int | None = None\n    visible: bool = True\n    sortable: bool = True\n    filterable: bool = True\n    resizable: bool = True\n    tooltip: bool = False\n    vertical_align: str = \"middle\"\n    horizontal_align: str = \"\"\n\n    def __post_init__(self):\n        if self.title is None:\n            object.__setattr__(self, \"title\", self.field.replace(\"_\", \" \").title())\n\n    def to_dict(self) -&gt; dict[str, Any]:\n        \"\"\"Convert the column definition to a dict for JSON serialization.\"\"\"\n        result = {\n            \"field\": self.field,\n            \"title\": self.title,\n            \"visible\": self.visible,\n            \"resizable\": self.resizable,\n            \"tooltip\": self.tooltip,\n            \"vertAlign\": self.vertical_align,\n            \"hozAlign\": self.horizontal_align,\n        }\n\n        mappings = {\n            \"width\": \"width\",\n            \"min_width\": \"minWidth\",\n            \"tabulator_formatter\": \"formatter\",\n            \"tabulator_formatter_params\": \"formatterParams\",\n        }\n\n        for name, tabulator_name in mappings.items():\n            if value := getattr(self, name):\n                result[tabulator_name] = value\n\n        if self.sortable:\n            result[\"sorter\"] = \"string\"\n        else:\n            result[\"headerSort\"] = False\n\n        return result\n</code></pre>"},{"location":"entities/column/#tables.table.ColumnDefinition.to_dict","title":"<code>to_dict()</code>","text":"<p>Convert the column definition to a dict for JSON serialization.</p> Source code in <code>ckanext/tables/table.py</code> <pre><code>def to_dict(self) -&gt; dict[str, Any]:\n    \"\"\"Convert the column definition to a dict for JSON serialization.\"\"\"\n    result = {\n        \"field\": self.field,\n        \"title\": self.title,\n        \"visible\": self.visible,\n        \"resizable\": self.resizable,\n        \"tooltip\": self.tooltip,\n        \"vertAlign\": self.vertical_align,\n        \"hozAlign\": self.horizontal_align,\n    }\n\n    mappings = {\n        \"width\": \"width\",\n        \"min_width\": \"minWidth\",\n        \"tabulator_formatter\": \"formatter\",\n        \"tabulator_formatter_params\": \"formatterParams\",\n    }\n\n    for name, tabulator_name in mappings.items():\n        if value := getattr(self, name):\n            result[tabulator_name] = value\n\n    if self.sortable:\n        result[\"sorter\"] = \"string\"\n    else:\n        result[\"headerSort\"] = False\n\n    return result\n</code></pre>"},{"location":"entities/table/","title":"Table Definition","text":"<p>The table definition holds the configuration for a table, including its columns, data source, and other options.</p> <p>Below you can check the available attributes of the <code>TableDefinition</code> class and their descriptions. Also, a full code is provided at the end of this document for reference.</p> <p>Table definition.</p> ATTRIBUTE DESCRIPTION <code>name</code> <p>Unique identifier for the table.</p> <p> TYPE: <code>str</code> </p> <code>data_source</code> <p>Data source for the table.</p> <p> TYPE: <code>BaseDataSource</code> </p> <code>ajax_url</code> <p>(Optional) URL to fetch data from. Defaults to an auto-generated URL.</p> <p> TYPE: <code>BaseDataSource</code> </p> <code>columns</code> <p>(Optional) List of ColumnDefinition objects.</p> <p> TYPE: <code>list[ColumnDefinition]</code> </p> <code>row_actions</code> <p>(Optional) List of RowActionDefinition objects.</p> <p> TYPE: <code>list[RowActionDefinition]</code> </p> <code>bulk_actions</code> <p>(Optional) List of BulkActionDefinition objects for action on multiple rows.</p> <p> TYPE: <code>list[BulkActionDefinition]</code> </p> <code>table_actions</code> <p>(Optional) List of TableActionDefinition objects for actions on the table itself.</p> <p> TYPE: <code>list[TableActionDefinition]</code> </p> <code>exporters</code> <p>(Optional) List of exporter classes for exporting table data.</p> <p> TYPE: <code>list[type[ExporterBase]]</code> </p> <code>placeholder</code> <p>(Optional) Placeholder text for an empty table.</p> <p> TYPE: <code>str | None</code> </p> <code>page_size</code> <p>(Optional) Number of rows per page. Defaults to 10.</p> <p> TYPE: <code>int</code> </p> <code>table_template</code> <p>(Optional) Template to render the table. Defaults to <code>tables/base.html</code>.</p> <p> TYPE: <code>str</code> </p> Source code in <code>ckanext/tables/table.py</code> <pre><code>@dataclass\nclass TableDefinition:\n    \"\"\"Table definition.\n\n    Attributes:\n        name: Unique identifier for the table.\n        data_source: Data source for the table.\n        ajax_url: (Optional) URL to fetch data from. Defaults to an auto-generated URL.\n        columns: (Optional) List of ColumnDefinition objects.\n        row_actions: (Optional) List of RowActionDefinition objects.\n        bulk_actions: (Optional) List of BulkActionDefinition objects for action on multiple rows.\n        table_actions: (Optional) List of TableActionDefinition objects for actions on the table itself.\n        exporters: (Optional) List of exporter classes for exporting table data.\n        placeholder: (Optional) Placeholder text for an empty table.\n        page_size: (Optional) Number of rows per page. Defaults to 10.\n        table_template: (Optional) Template to render the table. Defaults to `tables/base.html`.\n    \"\"\"\n\n    name: str\n    data_source: BaseDataSource\n    columns: list[ColumnDefinition] = dataclass_field(default_factory=list)\n    row_actions: list[RowActionDefinition] = dataclass_field(default_factory=list)\n    bulk_actions: list[BulkActionDefinition] = dataclass_field(default_factory=list)\n    table_actions: list[TableActionDefinition] = dataclass_field(default_factory=list)\n    exporters: list[type[ExporterBase]] = dataclass_field(default_factory=list)\n    placeholder: str | None = None\n    page_size: int = 10\n    table_template: str = \"tables/base.html\"\n\n    def __post_init__(self):\n        self.id = f\"table_{self.name}_{uuid.uuid4().hex[:8]}\"\n\n        if self.placeholder is None:\n            self.placeholder = tk._(\"No data found\")\n\n        if self.row_actions:\n            self.columns.append(\n                ColumnDefinition(\n                    field=COLUMN_ACTIONS_FIELD,\n                    title=tk._(\"\"),\n                    formatters=[(formatters.ActionsFormatter, {})],\n                    filterable=False,\n                    tabulator_formatter=\"html\",\n                    sortable=False,\n                    resizable=False,\n                    width=50,\n                ),\n            )\n\n    def get_tabulator_config(self) -&gt; dict[str, Any]:\n        columns = [col.to_dict() for col in self.columns]\n\n        options: dict[str, Any] = {\n            \"columns\": columns,\n            \"placeholder\": self.placeholder,\n            \"sortMode\": \"remote\",\n            \"layout\": \"fitColumns\",\n            \"pagination\": True,\n            \"paginationMode\": \"remote\",\n            \"paginationSize\": self.page_size,\n            \"paginationSizeSelector\": [5, 10, 25, 50, 100],\n            \"minHeight\": 300,\n        }\n\n        if bool(self.bulk_actions):\n            options.update(\n                {\n                    \"rowHeader\": {\n                        \"headerSort\": False,\n                        \"resizable\": False,\n                        \"headerHozAlign\": \"center\",\n                        \"hozAlign\": \"center\",\n                        \"vertAlign\": \"middle\",\n                        \"formatter\": \"rowSelection\",\n                        \"titleFormatter\": \"rowSelection\",\n                        \"width\": 50,\n                    }\n                }\n            )\n\n        return options\n\n    def get_row_actions(self) -&gt; dict[str, dict[str, Any]]:\n        return {\n            action.action: {\n                \"name\": action.action,\n                \"label\": action.label,\n                \"icon\": action.icon,\n                \"with_confirmation\": action.with_confirmation,\n            }\n            for action in self.row_actions\n        }\n\n    def render_table(self, **kwargs: Any) -&gt; str:\n        return tk.render(self.table_template, extra_vars={\"table\": self, **kwargs})\n\n    def get_data(self, params: QueryParams) -&gt; list[Any]:\n        return [self._apply_formatters(dict(row)) for row in self.get_raw_data(params)]\n\n    def get_raw_data(self, params: QueryParams, paginate: bool = True) -&gt; list[dict[str, Any]]:\n        if not paginate:\n            return self.data_source.filter(params.filters).sort(params.sort_by, params.sort_order).all()\n\n        return (\n            self.data_source.filter(params.filters)\n            .sort(params.sort_by, params.sort_order)\n            .paginate(params.page, params.size)\n            .all()\n        )\n\n    def get_total_count(self, params: QueryParams) -&gt; int:\n        # for total count we only apply filter, without sort and pagination\n        return self.data_source.filter(params.filters).count()\n\n    def _apply_formatters(self, row: dict[str, Any]) -&gt; dict[str, Any]:\n        \"\"\"Apply formatters to each cell in a row.\"\"\"\n        formatted_row = copy.deepcopy(row)\n\n        for column in self.columns:\n            cell_value = row.get(column.field)\n\n            if not column.formatters:\n                continue\n\n            for formatter_class, formatter_options in column.formatters:\n                cell_value = formatter_class(column, formatted_row, row, self).format(cell_value, formatter_options)\n\n            formatted_row[column.field] = cell_value\n\n        return formatted_row\n\n    @classmethod\n    def check_access(cls, context: Context) -&gt; None:\n        \"\"\"Check if the current user has access to view the table.\n\n        This class method can be overridden in subclasses to implement\n        custom access control logic.\n\n        By default, it checks if the user has the `sysadmin` permission,\n        which means that the table is available only to system administrators.\n\n        Raises:\n            tk.NotAuthorized: If the user does not have an access\n        \"\"\"\n        tk.check_access(\"sysadmin\", context)\n\n    def get_bulk_action(self, action: str) -&gt; BulkActionDefinition | None:\n        return next((a for a in self.bulk_actions if a.action == action), None)\n\n    def get_table_action(self, action: str) -&gt; TableActionDefinition | None:\n        return next((a for a in self.table_actions if a.action == action), None)\n\n    def get_row_action(self, action: str) -&gt; RowActionDefinition | None:\n        return next((a for a in self.row_actions if a.action == action), None)\n\n    def get_exporter(self, name: str) -&gt; type[ExporterBase] | None:\n        return next((e for e in self.exporters if e.name == name), None)\n</code></pre>"},{"location":"entities/table/#tables.table.TableDefinition.check_access","title":"<code>check_access(context)</code>  <code>classmethod</code>","text":"<p>Check if the current user has access to view the table.</p> <p>This class method can be overridden in subclasses to implement custom access control logic.</p> <p>By default, it checks if the user has the <code>sysadmin</code> permission, which means that the table is available only to system administrators.</p> RAISES DESCRIPTION <code>NotAuthorized</code> <p>If the user does not have an access</p> Source code in <code>ckanext/tables/table.py</code> <pre><code>@classmethod\ndef check_access(cls, context: Context) -&gt; None:\n    \"\"\"Check if the current user has access to view the table.\n\n    This class method can be overridden in subclasses to implement\n    custom access control logic.\n\n    By default, it checks if the user has the `sysadmin` permission,\n    which means that the table is available only to system administrators.\n\n    Raises:\n        tk.NotAuthorized: If the user does not have an access\n    \"\"\"\n    tk.check_access(\"sysadmin\", context)\n</code></pre>"},{"location":"exporters/","title":"Exporters","text":"<p>The tables extension provides several built-in exporters to export the table data in different formats. You can specify the exporters to be used in the <code>exporters</code> attribute of the <code>TableDefinition</code>.</p> <p>Each exporter is a class that inherits from <code>BaseExporter</code> and implements the <code>export</code> method.</p> <p>To use an exporter, you need to import the desired exporter from <code>ckanext.tables.shared</code> and add it to the <code>exporters</code> list in the <code>TableDefinition</code>.</p> <pre><code>import ckanext.tables.shared as t\n\nclass MyTable(t.TableDefinition):\n    def __init__(self):\n        super().__init__(\n            ...\n            exporters=[\n                t.exporters.CSVExporter,\n                t.exporters.TSVExporter,\n            ]\n        )\n</code></pre> <p>Below you can see the source code for the base exporter class.</p>"},{"location":"exporters/#tables.exporters.ExporterBase","title":"<code>ExporterBase</code>","text":"<p>Base class for table data exporters.</p> Source code in <code>ckanext/tables/exporters.py</code> <pre><code>class ExporterBase:\n    \"\"\"Base class for table data exporters.\"\"\"\n\n    name: str\n    label: str\n    mime_type: str\n\n    @classmethod\n    def export(cls, table: \"TableDefinition\", params: \"QueryParams\") -&gt; bytes:\n        \"\"\"Export the table data.\n\n        Args:\n            table: The table definition.\n            params: The query parameters.\n\n        Returns:\n            The exported data as bytes.\n        \"\"\"\n        raise NotImplementedError\n\n    @classmethod\n    def get_table_columns(cls, table: \"TableDefinition\") -&gt; list[\"ColumnDefinition\"]:\n        \"\"\"Get the list of table columns to be exported.\n\n        Returns:\n            A list of column field names.\n        \"\"\"\n        # avoid circular import\n        from ckanext.tables.table import COLUMN_ACTIONS_FIELD  # noqa PLC0415\n\n        return [col for col in table.columns if col.field != COLUMN_ACTIONS_FIELD]\n</code></pre>"},{"location":"exporters/#list-of-built-in-exporters","title":"List of Built-in Exporters","text":"<p>Below is a list of the available built-in exporters along with a brief description of each.</p>"},{"location":"exporters/#csv-exporter","title":"CSV Exporter","text":"<p>CSV exporter for table data.</p> Source code in <code>ckanext/tables/exporters.py</code> <pre><code>class CSVExporter(ExporterBase):\n    \"\"\"CSV exporter for table data.\"\"\"\n\n    name = \"csv\"\n    label = tk._(\"CSV\")\n    mime_type = \"text/csv\"\n\n    @classmethod\n    def export(cls, table: \"TableDefinition\", params: \"QueryParams\") -&gt; bytes:\n        output = StringIO()\n        writer = csv.writer(output)\n        columns = cls.get_table_columns(table)\n\n        header = [col.title for col in columns]\n        writer.writerow(header)\n\n        # Write data rows\n        data = table.get_raw_data(params, paginate=False)\n\n        for row in data:\n            writer.writerow([row.get(col.field, \"\") for col in columns])\n\n        return output.getvalue().encode(\"utf-8\")\n</code></pre>"},{"location":"exporters/#tsv-exporter","title":"TSV Exporter","text":"<p>TSV exporter for table data.</p> Source code in <code>ckanext/tables/exporters.py</code> <pre><code>class TSVExporter(ExporterBase):\n    \"\"\"TSV exporter for table data.\"\"\"\n\n    name = \"tsv\"\n    label = tk._(\"TSV\")\n    mime_type = \"text/tab-separated-values\"\n\n    @classmethod\n    def export(cls, table: \"TableDefinition\", params: \"QueryParams\") -&gt; bytes:\n        output = StringIO()\n        writer = csv.writer(output, delimiter=\"\\t\")\n\n        columns = cls.get_table_columns(table)\n        header = [col.title for col in columns]\n        writer.writerow(header)\n\n        # Rows\n        data = table.get_raw_data(params, paginate=False)\n        for row in data:\n            writer.writerow([row.get(col.field, \"\") for col in columns])\n\n        return output.getvalue().encode(\"utf-8\")\n</code></pre>"},{"location":"exporters/#json-exporter","title":"JSON Exporter","text":"<p>JSON exporter for table data.</p> Source code in <code>ckanext/tables/exporters.py</code> <pre><code>class JSONExporter(ExporterBase):\n    \"\"\"JSON exporter for table data.\"\"\"\n\n    name = \"json\"\n    label = tk._(\"JSON\")\n    mime_type = \"application/json\"\n\n    @classmethod\n    def export(cls, table: \"TableDefinition\", params: \"QueryParams\") -&gt; bytes:\n        data = table.get_raw_data(params, paginate=False)\n\n        return json.dumps(data, default=str).encode(\"utf-8\")\n</code></pre>"},{"location":"exporters/#xlsx-exporter","title":"XLSX Exporter","text":"<p>Excel (XLSX) exporter for table data.</p> Source code in <code>ckanext/tables/exporters.py</code> <pre><code>class XLSXExporter(ExporterBase):\n    \"\"\"Excel (XLSX) exporter for table data.\"\"\"\n\n    name = \"xlsx\"\n    label = tk._(\"Excel\")\n    mime_type = \"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\"\n\n    @classmethod\n    def export(cls, table: \"TableDefinition\", params: \"QueryParams\") -&gt; bytes:\n        try:\n            from openpyxl import Workbook  # noqa: PLC0415\n        except ImportError:\n            log.warning(\"openpyxl is required for XLSX export but is not installed.\")\n            return b\"\"\n\n        wb = Workbook()\n        ws = wb.active\n        ws.title = \"Data\"  # type: ignore\n\n        columns = cls.get_table_columns(table)\n        header = [col.title for col in columns]\n        ws.append(header)  # type: ignore\n\n        # Write data rows\n        data = table.get_raw_data(params, paginate=False)\n        for row in data:\n            ws.append([row.get(col.field, \"\") for col in columns])  # type: ignore\n\n        output = BytesIO()\n        wb.save(output)\n        return output.getvalue()\n</code></pre>"},{"location":"exporters/#html-exporter","title":"HTML Exporter","text":"<p>HTML exporter for table data.</p> Source code in <code>ckanext/tables/exporters.py</code> <pre><code>class HTMLExporter(ExporterBase):\n    \"\"\"HTML exporter for table data.\"\"\"\n\n    name = \"html\"\n    label = tk._(\"HTML\")\n    mime_type = \"text/html\"\n\n    @classmethod\n    def export(cls, table: \"TableDefinition\", params: \"QueryParams\") -&gt; bytes:\n        data = table.get_raw_data(params, paginate=False)\n        columns = cls.get_table_columns(table)\n        headers = [col.title for col in columns]\n\n        rows_html = \"\\n\".join(\n            \"&lt;tr&gt;{}&lt;/tr&gt;\".format(\"\".join(\"&lt;td&gt;{}&lt;/td&gt;\".format(row.get(col.field, \"\")) for col in columns))\n            for row in data\n        )\n        thead = \"&lt;tr&gt;{}&lt;/tr&gt;\".format(\"\".join(f\"&lt;th&gt;{h}&lt;/th&gt;\" for h in headers))\n        html = f\"\"\"\n        &lt;html&gt;\n            &lt;head&gt;&lt;meta charset=\"utf-8\"&gt;&lt;title&gt;{table.name}&lt;/title&gt;&lt;/head&gt;\n            &lt;body&gt;\n                &lt;table border=\"1\"&gt;\n                    &lt;thead&gt;{thead}&lt;/thead&gt;\n                    &lt;tbody&gt;{rows_html}&lt;/tbody&gt;\n                &lt;/table&gt;\n            &lt;/body&gt;\n        &lt;/html&gt;\n        \"\"\"\n        return html.encode(\"utf-8\")\n</code></pre>"},{"location":"exporters/#yaml-exporter","title":"YAML Exporter","text":"<p>YAML exporter for table data.</p> Source code in <code>ckanext/tables/exporters.py</code> <pre><code>class YAMLExporter(ExporterBase):\n    \"\"\"YAML exporter for table data.\"\"\"\n\n    name = \"yaml\"\n    label = tk._(\"YAML\")\n    mime_type = \"application/x-yaml\"\n\n    @classmethod\n    def export(cls, table: \"TableDefinition\", params: \"QueryParams\") -&gt; bytes:\n        data = table.get_raw_data(params, paginate=False)\n        return yaml.safe_dump(data, allow_unicode=True).encode(\"utf-8\")\n</code></pre>"},{"location":"exporters/#ndjson-exporter","title":"NDJSON Exporter","text":"<p>NDJSON exporter for table data.</p> Source code in <code>ckanext/tables/exporters.py</code> <pre><code>class NDJSONExporter(ExporterBase):\n    \"\"\"NDJSON exporter for table data.\"\"\"\n\n    name = \"ndjson\"\n    label = tk._(\"NDJSON\")\n    mime_type = \"application/x-ndjson\"\n\n    @classmethod\n    def export(cls, table: \"TableDefinition\", params: \"QueryParams\") -&gt; bytes:\n        data = table.get_raw_data(params, paginate=False)\n        lines = [json.dumps(row, default=str) for row in data]\n        return \"\\n\".join(lines).encode(\"utf-8\")\n</code></pre>"},{"location":"formatters/","title":"Formatters","text":"<p>The formatters are used to format the data in the table cells. They can be applied to columns in the table definition.</p> <p>To see the list of available built-in formatters, see the Available Built-in Formatters documentation.</p>"},{"location":"formatters/#usage","title":"Usage","text":"<p>Just import the desired formatter and add it to the <code>formatters</code> list in the <code>ColumnDefinition</code>.</p> <pre><code>from ckanext.tables.shared import formatters, ColumnDefinition\n\nColumnDefinition(\n    field=\"timestamp\",\n    formatters=[(formatters.DateFormatter, {\"date_format\": \"%Y-%m-%d %H:%M\"})],\n)\n</code></pre> <p>Result:</p> <p></p>"},{"location":"formatters/#multiple-formatters","title":"Multiple Formatters","text":"<p>It's possible to use multiple formatters on a single column. The formatters will be applied in the order they are defined. For example, to display a date in bold:</p> <pre><code>from ckanext.tables.shared import formatters, ColumnDefinition\n\nColumnDefinition(\n    field=\"timestamp\",\n    formatters=[\n        (formatters.DateFormatter, {\"date_format\": \"%Y-%m-%d %H:%M\"}),\n        (formatters.TextBoldFormatter, {})\n    ],\n    tabulator_formatter=\"html\",\n)\n</code></pre> <p>Note</p> <p>If your formatter returns <code>HTML</code>, you need to set <code>tabulator_formatter=\"html\"</code> on the column definition to allow <code>HTML</code> rendering.</p> <p></p>"},{"location":"formatters/#custom-formatters","title":"Custom Formatters","text":"<p>You can also create your own custom formatters. See the Custom Formatters documentation for more information.</p>"},{"location":"formatters/built-in/","title":"Available Built-in Formatters","text":"<p>The tables extension comes with several built-in formatters that you can use to format the data in your table columns.</p> <p>Using formatter is simple; you just need to import the desired formatter from <code>ckanext.tables.shared.formatters</code> and add it to the <code>formatters</code> list in the <code>ColumnDefinition</code>.</p> <pre><code>from ckanext.tables.shared import formatters, ColumnDefinition\n\nColumnDefinition(\n    field=\"timestamp\",\n    formatters=[(formatters.DateFormatter, {\"date_format\": \"%Y-%m-%d %H:%M\"})],\n)\n</code></pre> <p>Below is a list of the available built-in formatters along with a brief description of each.</p>"},{"location":"formatters/built-in/#tables.formatters.ActionsFormatter","title":"<code>ActionsFormatter</code>","text":"<p>Renders a template snippet to display row-level actions.</p> Options <ul> <li><code>template</code> (str): The path to the template to render.   Defaults to <code>tables/formatters/actions.html</code>.</li> </ul>"},{"location":"formatters/built-in/#tables.formatters.BooleanFormatter","title":"<code>BooleanFormatter</code>","text":"<p>Renders a boolean value as 'Yes' or 'No'.</p>"},{"location":"formatters/built-in/#tables.formatters.DateFormatter","title":"<code>DateFormatter</code>","text":"<p>Formats a datetime object into a more readable date.</p> Options <ul> <li><code>date_format</code> (str): The strftime format for the output.   Defaults to \"%d/%m/%Y - %H:%M\".</li> </ul>"},{"location":"formatters/built-in/#tables.formatters.DialogModalFormatter","title":"<code>DialogModalFormatter</code>","text":"<p>Renders a link that opens a dialog modal with detailed information.</p> Options <ul> <li><code>template</code> (str): The path to the template to render inside the modal.   Defaults to <code>tables/formatters/dialog_modal.html</code>.</li> <li><code>modal_title</code> (str): The title of the modal dialog.   Defaults to \"Details\".</li> <li><code>max_length</code> (int): The maximum length of the preview text before   truncation. Defaults to 100.</li> </ul>"},{"location":"formatters/built-in/#tables.formatters.JsonDisplayFormatter","title":"<code>JsonDisplayFormatter</code>","text":"<p>Renders a JSON object using a template snippet for display.</p> <p>Must be combined with <code>tabulator_formatter=\"html\"</code> in the ColumnDefinition to ensure proper HTML rendering in the frontend.</p>"},{"location":"formatters/built-in/#tables.formatters.ListFormatter","title":"<code>ListFormatter</code>","text":"<p>Renders a list as a comma-separated string.</p>"},{"location":"formatters/built-in/#tables.formatters.NoneAsEmptyFormatter","title":"<code>NoneAsEmptyFormatter</code>","text":"<p>Renders a <code>None</code> value as an empty string.</p>"},{"location":"formatters/built-in/#tables.formatters.TextBoldFormatter","title":"<code>TextBoldFormatter</code>","text":"<p>Renders text in bold.</p>"},{"location":"formatters/built-in/#tables.formatters.TrimStringFormatter","title":"<code>TrimStringFormatter</code>","text":"<p>Trims a string to a specified maximum length.</p> Options <ul> <li><code>max_length</code> (int): The maximum length of the string. Defaults to 79.</li> <li><code>add_ellipsis</code> (bool): Whether to add \"...\" if the string is trimmed.   Defaults to True.</li> </ul>"},{"location":"formatters/built-in/#tables.formatters.URLFormatter","title":"<code>URLFormatter</code>","text":"<p>Generates a clickable link for a URL.</p> Options <ul> <li><code>target</code> (str): The target attribute for the link. Defaults to \"_blank\".</li> </ul>"},{"location":"formatters/built-in/#tables.formatters.UserLinkFormatter","title":"<code>UserLinkFormatter</code>","text":"<p>Generates a link to a user's profile with a placeholder avatar.</p> <p>This is a custom, performant implementation that avoids expensive <code>user_show</code> calls for every row by using a placeholder. The <code>value</code> for this formatter should be a user ID.</p> Options <ul> <li><code>maxlength</code> (int): Maximum length of the user's display name. Defaults to 20.</li> <li><code>avatar</code> (int): The size of the avatar placeholder in pixels. Defaults to 20.</li> </ul>"},{"location":"formatters/custom/","title":"Custom Formatters","text":"<p>To create a custom formatter, you need to define a new class that inherits from <code>BaseFormatter</code> and implement the <code>format</code> method.</p> <p>Below is an example of how to create a simple custom formatter, that replaces the cell content with a bold \"Hello World\" text.</p> <pre><code>from ckanext.tables.shared import BaseFormatter\n\nclass MyCustomFormatter(BaseFormatter):\n    \"\"\"Replaces cell content with a bold Hello World.\"\"\"\n\n    def format(\n        self, value: types.Value, options: types.Options\n    ) -&gt; types.FormatterResult:\n        return tk.literal(f\"&lt;strong&gt;Hello World&lt;/strong&gt;\")\n</code></pre> <p>Each formatter has an access to the cell value and the options passed to the formatter. Also, <code>self.table</code>, <code>self.row</code>, and <code>self.column</code> attributes are available to access the table, row, and column definitions respectively.</p>"},{"location":"formatters/custom/#tables.formatters.BaseFormatter","title":"<code>BaseFormatter</code>","text":"<p>Abstract base class for all formatters.</p> Source code in <code>ckanext/tables/formatters.py</code> <pre><code>class BaseFormatter(abc.ABC):\n    \"\"\"Abstract base class for all formatters.\"\"\"\n\n    def __init__(\n        self,\n        column: table.ColumnDefinition,\n        row: types.Row,\n        initial_row: types.Row,\n        table: table.TableDefinition,\n    ):\n        self.column = column\n        self.row = row\n        self.initial_row = initial_row\n        self.table = table\n\n    @abc.abstractmethod\n    def format(self, value: types.Value, options: types.Options) -&gt; types.FormatterResult:\n        raise NotImplementedError\n</code></pre>"}]}