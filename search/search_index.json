{"config":{"lang":["en"],"separator":"[\\s\\-\\.\\_]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#ckanext-tables","title":"ckanext-tables","text":"<p>A CKAN extension to display tabular data in a nice way using Tabulator.</p> <p>See the documentation for more information.</p>"},{"location":"#tests","title":"Tests","text":"<p>To run the tests, do: <pre><code>pytest --ckan-ini=test.ini\n</code></pre></p>"},{"location":"#license","title":"License","text":"<p>AGPL</p>"},{"location":"generics/","title":"Generic Views","text":"<p>The <code>ckanext.tables.generics</code> module provides a ready-to-use view class that can render tables without writing custom view code.</p>"},{"location":"generics/#generictableview","title":"GenericTableView","text":"<p>The <code>GenericTableView</code> is a Flask <code>MethodView</code> that automatically renders any registered table definition.</p>"},{"location":"generics/#basic-usage","title":"Basic Usage","text":"<pre><code>from flask import Blueprint\nfrom ckanext.tables.shared import GenericTableView\n\n# Create a blueprint\nbp = Blueprint(\"my_tables\", __name__)\n\n# Add a route using GenericTableView\nbp.add_url_rule(\n    \"/admin/users\",\n    view_func=GenericTableView.as_view(\"users_table\", table=\"users\")\n)\n</code></pre>"},{"location":"generics/#constructor-parameters","title":"Constructor Parameters","text":"<ul> <li><code>table</code> (str, required): The name of the registered table definition</li> <li><code>breadcrumb_label</code> (str, optional): Label shown in breadcrumbs. Defaults to \"Table\"</li> <li><code>page_title</code> (str, optional): Page title shown in the browser/header. Defaults to empty string</li> </ul>"},{"location":"generics/#error-handling","title":"Error Handling","text":"<p>If the specified table is not found in the registry or the user isn\u2019t authorized, <code>GenericTableView</code> raises a <code>tk.ObjectNotFound</code> exception:</p>"},{"location":"generics/#access-control","title":"Access Control","text":"<p>The <code>GenericTableView</code> delegates access control to the table definition's <code>check_access()</code> method. Make sure your table definitions implement proper authorization:</p> <pre><code>class MyTableDefinition(TableDefinition):\n    @classmethod\n    def check_access(cls, context: Context) -&gt; None:\n        \"\"\"Only allow sysadmins to view this table.\"\"\"\n        tk.check_access(\"sysadmin\", context)\n</code></pre>"},{"location":"helpers/","title":"Helper Functions","text":"<p>CKAN helper functions are typically used in templates, but also available everywhere with <code>toolkit.h.helper_name()</code>.</p>"},{"location":"helpers/#tables.helpers.tables_get_table","title":"<code>tables_get_table(table_name)</code>","text":"<p>Get a table definition by its name.</p> PARAMETER DESCRIPTION <code>table_name</code> <p>The name of the table to get</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>TableDefinition | None</code> <p>The table definition or None if the table does not exist</p> Source code in <code>ckanext/tables/helpers.py</code> <pre><code>def tables_get_table(table_name: str) -&gt; table.TableDefinition | None:\n    \"\"\"Get a table definition by its name.\n\n    Args:\n        table_name: The name of the table to get\n\n    Returns:\n        The table definition or None if the table does not exist\n    \"\"\"\n    table_class = table.table_registry.get(table_name)\n\n    if not table_class:\n        return None\n\n    try:\n        table_class.check_access({\"user\": tk.current_user.name})\n    except tk.NotAuthorized:\n        return None\n\n    return table_class\n</code></pre>"},{"location":"helpers/#tables.helpers.tables_json_dumps","title":"<code>tables_json_dumps(value)</code>","text":"<p>Convert a value to a JSON string.</p> PARAMETER DESCRIPTION <code>value</code> <p>The value to convert to a JSON string</p> <p> TYPE: <code>Any</code> </p> RETURNS DESCRIPTION <code>str</code> <p>The JSON string</p> Source code in <code>ckanext/tables/helpers.py</code> <pre><code>def tables_json_dumps(value: Any) -&gt; str:\n    \"\"\"Convert a value to a JSON string.\n\n    Args:\n        value: The value to convert to a JSON string\n\n    Returns:\n        The JSON string\n    \"\"\"\n    return json.dumps(value)\n</code></pre>"},{"location":"install/","title":"Installation","text":""},{"location":"install/#requirements","title":"Requirements","text":"<p>Python 3.10+</p> <p>Compatibility with core CKAN versions:</p> CKAN version Compatible? 2.9 and earlier no 2.10 yes 2.11 yes master not tested"},{"location":"install/#installation_1","title":"Installation","text":"<p>To install <code>ckanext-tables</code>, do the following:</p> <ul> <li> <p>Activate your CKAN virtualenv and install the extension with <code>pip</code>:</p> <pre><code>pip install ckanext-tables\n</code></pre> </li> <li> <p>Add <code>tables</code> to the <code>ckan.plugins</code> setting in your CKAN    config file (by default the config file is located at    <code>/etc/ckan/default/ckan.ini</code>).</p> <pre><code>ckan.plugins = ... tables ...\n</code></pre> </li> </ul>"},{"location":"install/#developer-installation","title":"Developer installation","text":"<p>To install <code>ckanext-tables</code> for development, activate your CKAN virtualenv and do:</p> <pre><code>git clone https://github.com/DataShades/ckanext-tables.git\ncd ckanext-tables\npip install -e '.[docs,test]'\n</code></pre>"},{"location":"usage/","title":"Basic usage","text":"<p>Here you can find complete usage instructions for the Tables extension. The process is fairly simple and involves only several steps:</p> <ol> <li>Defining a Table</li> <li>Registering a Table</li> <li>Creating a view to display the table</li> </ol>"},{"location":"usage/#defining-a-table","title":"Defining a Table","text":"<p>First, create a table definition by inheriting from <code>TableDefinition</code>.</p> <p>We will use the <code>ListDataSource</code> for demonstration purposes, but in a real-world scenario, you might want to use <code>DatabaseDataSource</code> or create a custom data source. Read more about data sources here.</p> <pre><code># table.py\n\nfrom ckanext.tables.shared import (\n    ColumnDefinition,\n    ListDataSource,\n    TableDefinition,\n    formatters,\n)\n\n\nclass PeopleTable(TableDefinition):\n    \"\"\"Demo table definition for the people table.\"\"\"\n\n    def __init__(self):\n        super().__init__(\n            name=\"people\",\n            data_source=ListDataSource(\n                data=[\n                    {\"id\": 1, \"name\": \"Alice\", \"surname\": \"Green\", \"created\": \"2024-07-30T15:44:27.801949\"},\n                    {\"id\": 2, \"name\": \"Bob\", \"surname\": \"Brown\", \"created\": \"2024-01-11T08:44:27.801949\"},\n                    {\"id\": 3, \"name\": \"Charlie\", \"surname\": \"Black\", \"created\": \"2025-05-25T21:44:27.801949\"},\n                    {\"id\": 4, \"name\": \"Diana\", \"surname\": \"White\", \"created\": \"2025-03-17T12:44:27.801949\"},\n                    {\"id\": 5, \"name\": \"Eve\", \"surname\": \"Gray\", \"created\": \"2023-04-21T13:44:27.801949\"},\n                ]\n            ),\n            columns=[\n                ColumnDefinition(field=\"id\"),\n                ColumnDefinition(field=\"name\"),\n                ColumnDefinition(field=\"surname\", title=\"Last Name\"),\n                ColumnDefinition(\n                    field=\"created\",\n                    formatters=[(formatters.DateFormatter, {\"date_format\": \"%d %B %Y\"})],\n                ),\n            ],\n        )\n</code></pre>"},{"location":"usage/#using-formatters","title":"Using Formatters","text":"<p>The tables extension provides several built-in formatters to change the way data is rendered in the table cells. You can apply one or more formatters to a column by specifying them in the <code>formatters</code> attribute of <code>ColumnDefinition</code>.:</p> <p>For example, from the above <code>PeopleTable</code>, we are using the <code>datetime</code> formatter to format the <code>created</code> field. So this <code>2024-02-25T11:10:00Z</code> value will be displayed as <code>2024-02-25</code>.</p> <pre><code>ColumnDefinition(\n    field=\"created\",\n    formatters=[(\"datetime\", {\"format\": \"%Y-%m-%d\"})],\n    sortable=True\n),\n</code></pre>"},{"location":"usage/#registering-the-table","title":"Registering the Table","text":"<p>To make your table available in the system, register it using the <code>ISignal</code> interface in your plugin:</p> <pre><code># plugin.py\n\nfrom typing import Any\n\nfrom ckan import plugins, types\nfrom ckan.plugins import toolkit as tk\n\nfrom ckanext.tables_demo.table import PeopleTable\n\n\nclass MyPlugin(plugins.SingletonPlugin):\n    plugins.implements(plugins.ISignal)\n\n    # ISignal\n\n    def get_signal_subscriptions(self) -&gt; types.SignalMapping:\n        return {\n            tk.signals.ckanext.signal(\"ckanext.tables.register_tables\"): [\n                self.collect_tables\n            ],\n        }\n\n    def collect_tables(self, sender: None) -&gt; dict[str, type[Any]]:\n        return {\"people\": PeopleTable}\n</code></pre>"},{"location":"usage/#creating-a-view","title":"Creating a View","text":"<p>Once your table is registered, you can create a view to display it using the <code>GenericTableView</code>:</p> <pre><code># views.py\n\nfrom flask import Blueprint\n\nfrom ckanext.tables.shared import GenericTableView\n\n\nbp = Blueprint(\"my_tables\", __name__, url_prefix=\"/admin\")\n\nbp.add_url_rule(\n    \"/people\",\n    view_func=GenericTableView.as_view(\n        \"people_table\",\n        table=\"people\",  # Must match the registered table name\n    ),\n)\n</code></pre>"},{"location":"usage/#results","title":"Results","text":"<p>After completing the above steps, you can navigate to <code>/admin/people</code> in your CKAN instance to see the rendered table.</p> <p></p>"},{"location":"usage/#next-steps","title":"Next Steps","text":"<ul> <li>Learn about Data Sources for different data backends</li> <li>Explore Built-In and Custom Formatters to enhance table presentation.</li> </ul>"},{"location":"data_sources/","title":"Data Sources","text":"<p>Data sources provide the underlying data for table definitions. They handle filtering, sorting, and pagination operations while abstracting away the specific data storage mechanism.</p> <p>Each table definition must specify a data source to fetch its data from.</p> <p>The list of available data sources includes:</p> <ul> <li><code>DatabaseDataSource</code>: Uses SQLAlchemy statements to fetch data from the database. This is the most common data source for production use.</li> <li><code>ListDataSource</code>: Uses an in-memory list of dictionaries. This is useful for small datasets or testing.</li> </ul>"},{"location":"data_sources/database/","title":"DatabaseDataSource","text":"<p>The <code>DatabaseDataSource</code> uses SQLAlchemy statements to fetch data from the database. This is the most common data source for production use.</p>"},{"location":"data_sources/database/#basic-usage","title":"Basic Usage","text":"<pre><code>from sqlalchemy import select\n\nfrom ckan import model\n\nfrom ckanext.tables.shared import DatabaseDataSource\n\n\ndata_source = DatabaseDataSource(\n    stmt=select(\n        model.User.id,\n        model.User.email,\n        model.User.name,\n        model.User.state,\n    ).order_by(model.User.created.desc()),\n    model=model.User,\n)\n</code></pre>"},{"location":"data_sources/database/#definition","title":"Definition","text":"<p>A data source that uses a SQLAlchemy statement as the data source.</p> PARAMETER DESCRIPTION <code>stmt</code> <p>The SQLAlchemy statement to use as the data source</p> <p> TYPE: <code>Select</code> </p> <code>model</code> <p>The model class to use for filtering and sorting, e.g. <code>model.User</code></p> <p> TYPE: <code>type[Any]</code> </p> Source code in <code>ckanext/tables/data_sources.py</code> <pre><code>class DatabaseDataSource(BaseDataSource):\n    \"\"\"A data source that uses a SQLAlchemy statement as the data source.\n\n    Args:\n        stmt: The SQLAlchemy statement to use as the data source\n        model: The model class to use for filtering and sorting, e.g. `model.User`\n    \"\"\"\n\n    def __init__(self, stmt: Select, model: type[Any]):\n        self.base_stmt = stmt\n        self.stmt = stmt\n        self.model = model\n\n    def filter(self, field: str | None, operator: str | None, value: str | None) -&gt; Self:\n        if field and hasattr(self.model, field) and value and operator:\n            col = getattr(self.model, field)\n            expr = self.build_filter(col, operator, value)\n\n            if expr is not None:\n                self.stmt = self.stmt.where(expr)\n\n        return self\n\n    def build_filter(self, column: ColumnElement, operator: str, value: str) -&gt; BinaryExpression | ClauseElement | None:\n        try:\n            if isinstance(column.type, Boolean):\n                casted_value = value.lower() in (\"true\", \"1\", \"yes\", \"y\")\n            elif isinstance(column.type, Integer):\n                casted_value = int(value)\n            elif isinstance(column.type, DateTime):\n                casted_value = datetime.fromisoformat(value)\n            else:\n                casted_value = str(value)\n        except ValueError:\n            return None\n\n        operators: dict[\n            str,\n            Callable[[ColumnElement, Any], BinaryExpression | ClauseElement | None],\n        ] = {\n            \"=\": lambda col, val: col == val,\n            \"&lt;\": lambda col, val: col &lt; val,\n            \"&lt;=\": lambda col, val: col &lt;= val,\n            \"&gt;\": lambda col, val: col &gt; val,\n            \"&gt;=\": lambda col, val: col &gt;= val,\n            \"!=\": lambda col, val: col != val,\n            \"like\": lambda col, val: (col.ilike(f\"%{val}%\") if isinstance(val, str) else None),\n        }\n\n        func = operators.get(operator)\n        return func(column, casted_value) if func else None\n\n    def sort(self, sort_by: str | None, sort_order: str | None) -&gt; Self:\n        if not sort_by or not hasattr(self.model, sort_by):\n            return self\n\n        col = getattr(self.model, sort_by)\n\n        # Clear existing order_by clauses\n        self.stmt = self.stmt.order_by(None)\n\n        if sort_order and sort_order.lower() == \"desc\":\n            self.stmt = self.stmt.order_by(col.desc())\n        else:\n            self.stmt = self.stmt.order_by(col.asc())\n\n        return self\n\n    def paginate(self, page: int, size: int) -&gt; Self:\n        if page and size:\n            self.stmt = self.stmt.limit(size).offset((page - 1) * size)\n\n        return self\n\n    def all(self):\n        return [dict(row) for row in model.Session.execute(self.stmt).mappings().all()]\n\n    def count(self):\n        return model.Session.execute(select(func.count()).select_from(self.base_stmt.subquery())).scalar_one()\n</code></pre>"},{"location":"data_sources/database/#best-practices","title":"Best Practices","text":"<ul> <li>Use selective queries</li> <li>Add database indexes for commonly filtered/sorted columns</li> </ul> <pre><code># Good: Select only needed columns\nstmt = select(model.User.id, model.User.name, model.User.email)\n\n# Avoid: Selecting everything\nstmt = select(model.User)\n</code></pre>"},{"location":"data_sources/list/","title":"ListDataSource","text":"<p>The <code>ListDataSource</code> works with Python lists of dictionaries. It's useful for testing, demos, or when working with pre-loaded data.</p>"},{"location":"data_sources/list/#basic-usage","title":"Basic Usage","text":"<pre><code>from ckanext.tables.shared import ListDataSource\n\n# Sample data\nusers_data = [\n    {\"id\": 1, \"name\": \"alice\", \"email\": \"alice@example.com\", \"age\": 30},\n    {\"id\": 2, \"name\": \"bob\", \"email\": \"bob@example.com\", \"age\": 25},\n    {\"id\": 3, \"name\": \"charlie\", \"email\": \"charlie@example.com\", \"age\": 35},\n]\n\ndata_source = ListDataSource(users_data)\n</code></pre>"},{"location":"data_sources/list/#definition","title":"Definition","text":"<p>A data source that uses a list of dictionaries as the data source.</p> <p>This is useful for testing and demo purposes, when you already have data on your hand.</p> PARAMETER DESCRIPTION <code>data</code> <p>The list of dictionaries to use as the data source</p> <p> TYPE: <code>list[dict[str, Any]]</code> </p> Source code in <code>ckanext/tables/data_sources.py</code> <pre><code>class ListDataSource(BaseDataSource):\n    \"\"\"A data source that uses a list of dictionaries as the data source.\n\n    This is useful for testing and demo purposes, when you already have data\n    on your hand.\n\n    Args:\n        data: The list of dictionaries to use as the data source\n\n    \"\"\"\n\n    def __init__(self, data: list[dict[str, Any]]):\n        self.data = data\n        self.filtered = data\n\n    def filter(self, field: str | None, operator: str | None, value: str | None) -&gt; Self:\n        if field and operator and value:\n            pred = self.build_filter(field, operator, value)\n            if pred:\n                self.filtered = [row for row in self.filtered if pred(row)]\n        return self\n\n    def build_filter(self, field: str, operator: str, value: str) -&gt; Callable[[dict[str, Any]], bool] | None:\n        operators: dict[str, Callable[[str, str], bool]] = {\n            \"=\": lambda a, b: a == b,\n            \"!=\": lambda a, b: a != b,\n            \"&lt;\": lambda a, b: a &lt; b,\n            \"&lt;=\": lambda a, b: a &lt;= b,\n            \"&gt;\": lambda a, b: a &gt; b,\n            \"&gt;=\": lambda a, b: a &gt;= b,\n            \"like\": lambda a, b: b.lower() in a.lower(),\n        }\n\n        op_func = operators.get(operator)\n        if not op_func:\n            return None\n\n        return lambda row: op_func(str(row.get(field, \"\")), str(value))\n\n    def sort(self, sort_by: str | None, sort_order: str | None) -&gt; Self:\n        if sort_by:\n            reverse = (sort_order or \"\").lower() == \"desc\"\n            self.filtered = sorted(self.filtered, key=lambda x: x.get(sort_by), reverse=reverse)\n        return self\n\n    def paginate(self, page: int, size: int) -&gt; Self:\n        if page and size:\n            start = (page - 1) * size\n            end = start + size\n            self.filtered = self.filtered[start:end]\n        return self\n\n    def all(self):\n        return self.filtered\n\n    def count(self):\n        return len(self.data)\n</code></pre>"},{"location":"data_sources/list/#best-practices","title":"Best Practices","text":"<ul> <li>Suitable for small amout of data</li> <li>Consider caching expensive data preparation</li> </ul>"},{"location":"formatters/","title":"Formatters","text":"<p>The formatters are used to format the data in the table cells. They can be applied to columns in the table definition.</p> <p>To see the list of available built-in formatters, see the Available Built-in Formatters documentation.</p>"},{"location":"formatters/#usage","title":"Usage","text":"<p>Just import the desired formatter and add it to the <code>formatters</code> list in the <code>ColumnDefinition</code>.</p> <pre><code>from ckanext.tables.shared import formatters, ColumnDefinition\n\nColumnDefinition(\n    field=\"timestamp\",\n    formatters=[(formatters.DateFormatter, {\"date_format\": \"%Y-%m-%d %H:%M\"})],\n)\n</code></pre> <p>Result:</p> <p></p>"},{"location":"formatters/#multiple-formatters","title":"Multiple Formatters","text":"<p>It's possible to use multiple formatters on a single column. The formatters will be applied in the order they are defined. For example, to display a date in bold:</p> <pre><code>from ckanext.tables.shared import formatters, ColumnDefinition\n\nColumnDefinition(\n    field=\"timestamp\",\n    formatters=[\n        (formatters.DateFormatter, {\"date_format\": \"%Y-%m-%d %H:%M\"}),\n        (formatters.TextBoldFormatter, {})\n    ],\n    tabulator_formatter=\"html\",\n)\n</code></pre> <p>Note</p> <p>If your formatter returns <code>HTML</code>, you need to set <code>tabulator_formatter=\"html\"</code> on the column definition to allow <code>HTML</code> rendering.</p> <p></p>"},{"location":"formatters/#custom-formatters","title":"Custom Formatters","text":"<p>You can also create your own custom formatters. See the Custom Formatters documentation for more information.</p>"},{"location":"formatters/built-in/","title":"Available Built-in Formatters","text":""},{"location":"formatters/built-in/#tables.formatters.ActionsFormatter","title":"<code>ActionsFormatter</code>","text":"<p>Renders a template snippet to display row-level actions.</p> Options <ul> <li><code>template</code> (str): The path to the template to render.   Defaults to <code>tables/formatters/actions.html</code>.</li> </ul>"},{"location":"formatters/built-in/#tables.formatters.BooleanFormatter","title":"<code>BooleanFormatter</code>","text":"<p>Renders a boolean value as 'Yes' or 'No'.</p>"},{"location":"formatters/built-in/#tables.formatters.DateFormatter","title":"<code>DateFormatter</code>","text":"<p>Formats a datetime string into a more readable date.</p> Options <ul> <li><code>date_format</code> (str): The strftime format for the output.   Defaults to \"%d/%m/%Y - %H:%M\".</li> </ul>"},{"location":"formatters/built-in/#tables.formatters.JsonDisplayFormatter","title":"<code>JsonDisplayFormatter</code>","text":"<p>Renders a JSON object using a template snippet for display.</p> <p>Must be combined with <code>tabulator_formatter=\"html\"</code> in the ColumnDefinition to ensure proper HTML rendering in the frontend.</p>"},{"location":"formatters/built-in/#tables.formatters.ListFormatter","title":"<code>ListFormatter</code>","text":"<p>Renders a list as a comma-separated string.</p>"},{"location":"formatters/built-in/#tables.formatters.NoneAsEmptyFormatter","title":"<code>NoneAsEmptyFormatter</code>","text":"<p>Renders a <code>None</code> value as an empty string.</p>"},{"location":"formatters/built-in/#tables.formatters.TextBoldFormatter","title":"<code>TextBoldFormatter</code>","text":"<p>Renders text in bold.</p>"},{"location":"formatters/built-in/#tables.formatters.TrimStringFormatter","title":"<code>TrimStringFormatter</code>","text":"<p>Trims a string to a specified maximum length.</p> Options <ul> <li><code>max_length</code> (int): The maximum length of the string. Defaults to 79.</li> <li><code>add_ellipsis</code> (bool): Whether to add \"...\" if the string is trimmed.   Defaults to True.</li> </ul>"},{"location":"formatters/built-in/#tables.formatters.UserLinkFormatter","title":"<code>UserLinkFormatter</code>","text":"<p>Generates a link to a user's profile with a placeholder avatar.</p> <p>This is a custom, performant implementation that avoids expensive <code>user_show</code> calls for every row by using a placeholder. The <code>value</code> for this formatter should be a user ID.</p> Options <ul> <li><code>maxlength</code> (int): Maximum length of the user's display name. Defaults to 20.</li> <li><code>avatar</code> (int): The size of the avatar placeholder in pixels. Defaults to 20.</li> </ul>"},{"location":"formatters/custom/","title":"Custom Formatters","text":"<p>To create a custom formatter, you need to define a new class that inherits from <code>BaseFormatter</code> and implement the <code>format</code> method.</p> <p>Below is an example of how to create a simple custom formatter, that replaces the cell content with a bold \"Hello World\" text.</p> <pre><code>from ckanext.tables.shared import BaseFormatter\n\nclass MyCustomFormatter(BaseFormatter):\n    \"\"\"Replaces cell content with a bold Hello World.\"\"\"\n\n    def format(\n        self, value: types.Value, options: types.Options\n    ) -&gt; types.FormatterResult:\n        return tk.literal(f\"&lt;strong&gt;Hello World&lt;/strong&gt;\")\n</code></pre> <p>Each formatter has an access to the cell value and the options passed to the formatter. Also, <code>self.table</code>, <code>self.row</code>, and <code>self.column</code> attributes are available to access the table, row, and column definitions respectively.</p>"},{"location":"formatters/custom/#tables.formatters.BaseFormatter","title":"<code>BaseFormatter</code>","text":"<p>Abstract base class for all formatters.</p> Source code in <code>ckanext/tables/formatters.py</code> <pre><code>class BaseFormatter(abc.ABC):\n    \"\"\"Abstract base class for all formatters.\"\"\"\n\n    def __init__(\n        self,\n        column: type[table.ColumnDefinition],\n        row: types.Row,\n        table: table.TableDefinition,\n    ):\n        self.column = column\n        self.row = row\n        self.table = table\n\n    @abc.abstractmethod\n    def format(\n        self, value: types.Value, options: types.Options\n    ) -&gt; types.FormatterResult:\n        raise NotImplementedError\n</code></pre>"}]}